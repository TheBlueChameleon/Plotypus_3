#include <complex>
#include <iostream>

#include "showcase.h"
#include "../plotypus.h"

using namespace std::complex_literals;
using namespace std::string_literals;

// ========================================================================== //
// behaviour constants

/* set this to true to also generate a human readable, CSV-like output of your
 * data to be processed by other software
 */
bool SHOWCASE_TXT_REPORT = false;

// ========================================================================== //

void showcase_minimal()
{
    /* This example shows the very minimal code needed to create plots from
     * data in memory.
     *
     * Creating more fancy output is showcased in the other routines of this
     * module.
     */

    // ---------------------------------------------------------------------- //
    // prepare data

    /* The below code is a stand in for an arbitrary complex simulation.
     * Here, we simply sample a sine wave at equidistant points and use a
     * single std::vector as data source for our plot.
     */

    std::vector<double> data;

    double x = 0.;
    while (x < 2*pi)
    {
        data.push_back( std::sin(x) );
        x += .05;
    }

    // ---------------------------------------------------------------------- //
    // prepare report, i.e. the primary object

    /* A Plotypus::Report is a collection of plot descriptions and format
     * specifications, complete with code to persist data, gnuplot script and
     * the created plots to the hard disk.
     * You will need to create such an object in each project involving
     * Plotypus.
     */

    Plotypus::Report report = Plotypus::Report();
    report
    .setOutputDirectory("../TestOutput")
    .setFilenameBase("minimal");

    /* The behaviour of a report -- like all Plotypus elements -- can be
     * modified by using one or several setters. Usually, they can be chained,
     * as in the example above.
     *
     * In this case, we set the directory into which all files generated by
     * Plotypus are written (in this case "../TestOutput"), as well as the
     * filename base, i.e. the common prefix for all files.
     * Since a report can comprise of several plots (arranged in multiple
     * pages), multiple data files will be generated, following the pattern
     *
     *     <filenameBase>_<page>_<plot>.<ext>
     *
     * The extension can be chosen using similar setter methods. You can rely
     * on Plotypus selecting resonalbe default values.
     *
     * In the above example, ...
     * - the generated plot will be of filetype PDF and have the
     *   filename minimal.pdf
     * - the gnuplot script generating this PDF will have the filename
     *   minimal.gnuplot
     * - the datafile referenced by the gnuplot script will have the filename
     *   minimal_1_1.dat
     * - optionally, a human readable TXT report can be generated (see below).
     *   It will be stored in minimal.txt
     */

    // ---------------------------------------------------------------------- //
    // define the report elements

    /* To populate your report, first add at least one Plot page, onto which
     * you then put at least one Dataview:
     */

    report
    .addPlotDefault("Minimal Plotypus Example")
    .addDataviewDefaultSeparate(data, Plotypus::PlotStyle::Lines, "sine wave")
    ;

    /* A PlotDefault is one of several variations of a Plotypus::Sheet, i.e.
     * a representation of one page in a multipage document. Different Sheets
     * provide different capabilities.
     * PlotDefault is the most versatile thereof.
     *
     * A Dataview is the representation of one "line" in the plot. It needs to
     * "know" the data that should be plotted, and how these data are to be
     * rendered (e.g. as a line plot, bar chart, ...).
     * DataviewSeparate is conceptually the easiest to handle. It takes one or
     * several std::vector<double>s containing the Y-data (minimum description),
     * X-data, error margins and so on.
     * If data are missing (like here the X-data), gnuplot will use default
     * values (e.g. using the index of the values in data as x-coordinate).
     * Not all plot types are possible with Y values alone.
     *
     * See the other examples for how to add more information to a Dataview.
     */

    // ---------------------------------------------------------------------- //
    // use the report writer(s)

    report.writeReport();       // generates the dat files, the gnuplot script and executes it
    if (SHOWCASE_TXT_REPORT)
    {
        report.writeTxt();      // generates a CSV like, human readable file
    }
}
// ========================================================================== //
// exposed interface

void showcase_run(size_t selection)
{
    /* If you find your way around the minimal example above, you'll find
     * nothing funny going on here. The function prepares one shared
     * Plotypus::Report that is passed to a number of functions, each of
     * which adds one or more pages to the report, thereby showcasing the
     * capabilities and mode of usage of Plotypus.
     *
     * This function ties the various examples together by creating the
     * Report object, the data and calling the code to add the pages.
     *
     * At the end (after defining the report elements), the write-to-disk
     * commands are invoked.
     */

    // ---------------------------------------------------------------------- //
    // prepare report, i.e. the primary object

    Plotypus::Report report = Plotypus::Report();
    report
    .setOutputDirectory("../TestOutput")
    .setFilenameBase("extended")
    ;

    // ---------------------------------------------------------------------- //
    // prepare some data (so they persist in memory until we write the report)

    std::array<std::vector<double>, 5> separate_data = generateSeparateData2D();
    std::vector<compound_t>            compound_data = generateCompoundData2D();
    std::vector<compound_complex_t>    compound_complex = generateVectorField();
    std::array<std::vector<double>, 3> separate_field   = generateScalarField();

    // ---------------------------------------------------------------------- //
    // run desired showcase options

    // *INDENT-OFF*
    if (selection & Showcases::Overlays)            {showcase_run_overlays(report);}
    if (selection & Showcases::Plot_SeparateSimple) {showcase_run_separateSimple(report, separate_data[0], separate_data[1]);}
    if (selection & Showcases::Plot_CompoundSimple) {showcase_run_compoundSimple(report, compound_data);}
    if (selection & Showcases::Plot_Multiplot)      {showcase_run_plots_multiplot(report);}
    if (selection & Showcases::FrameControls)       {showcase_run_frameControls(report);}
    if (selection & Showcases::Plots_2D_Variety)    {showcase_run_plots2d_variety(report, separate_data, compound_data);}
    if (selection & Showcases::Plots_2D_Maps)       {showcase_run_plots2d_maps(report, compound_complex, separate_field);}
    if (selection & Showcases::Plots_3D)            {showcase_run_plots3d(report, separate_field);}
    // *INDENT-ON*

    // ---------------------------------------------------------------------- //
    // write the report

    /* In the minimal example, we used report.writeReport(), which is merely
     * a wrapper calling the two functions below in sequence:
     */

    report.writeDat();
    report.writeScript();

    /* The TXT report is a useful tool for debugging but often not needed.
     * Hence, it is not generated by calling writeReport, but needs to
     * be triggered manually by calling the method writeTxt.
     */
    if (SHOWCASE_TXT_REPORT)
    {
        report.writeTxt();      // generates a CSV like, human readable file
    }
}

// ========================================================================== //
// showcases

void showcase_run_overlays(Plotypus::Report& report)
{
    using namespace Plotypus;

    auto& stylesCollection = report.stylesCollection();

    int boxStyleOffset = stylesCollection.getBoxStyleCount();

    stylesCollection.addBoxStyle("cyan", true, "blue");
    stylesCollection.addBoxStyle("", true, "blue");

    // ---------------------------------------------------------------------- //
    // Sheet 1: text boxes

    auto& sheet1 = report.addSheet("text overlay features");

    sheet1.addLabel("FOO BAR", .10, .10);
    sheet1.addLabel("auto-boxed", .30, .10, true);
    sheet1.addLabel("explicitly boxed", .50, .10, true, boxStyleOffset);

    sheet1.addLabel("normal text", .10, .20).setTextcolor("blue");
    sheet1.addLabel("abcdefghijklmnopqrstuvwxyz01234567890  ", .10, .26, true);
    sheet1.addLabel("ABCDEFGHIJKLMNOPQRSTUVWXYZ=!\"ยง$%&/()= ", .10, .32, true);

    sheet1.addLabel("greek font", .10, .45).setTextcolor("blue");
    sheet1.addLabel("{/symbol abcdefghijklmnopqrstuvwxyz01234567890} ", .10, .51, true);
    sheet1.addLabel("{/symbol ABCDEFGHIJKLMNOPQRSTUVWXYZ=!\"ยง$%&/()=}", .10, .57, true);

    sheet1.addLabel("dingbats font", .10, .70).setTextcolor("blue");
    sheet1.addLabel("{/zapfdingbats abcdefghijklmnopqrstuvwxyz01234567890}", .10, .76, true);
    sheet1.addLabel("{/zapfdingbats ABCDEFGHIJKLMNOPQRSTUVWXYZ=!\"ยง$%&/()=}", .10, .82, true);

    sheet1.addLabel("some special symbols", .70, .20).setTextcolor("blue");
    sheet1.addLabel(""s + SYMBOL_FORALL + SYMBOL_ALPHA + SYMBOL_DOT + "5" + SYMBOL_HBAR, .70, .26, true);

    sheet1.addLabel("implicitly escaping symbols", .70, .45).setTextcolor("blue");
    sheet1.addLabel(""s
                    + SYMBOL_TILDE + "a"
                    + SYMBOL_FORWARD_SLASH + "a"
                    + SYMBOL_BACKWARD_SLASH + "a"
                    + SYMBOL_AMPERSAND + "a"
                    + SYMBOL_AT + "ax"
                    + SYMBOL_CURLY_BRACE_OPEN + "a" + SYMBOL_CURLY_BRACE_CLOSE,
                    .70, .51, true);
}

// -------------------------------------------------------------------------- //

void showcase_run_separateSimple(Plotypus::Report& report,
                                 std::vector<double>& dataX, std::vector<double>& dataY)
{
    /* locally using namespace Plotypus will save you a lot of typing while
     * still protecting you from most name collisions in the rest of your
     * project.
     */

    using namespace Plotypus;

    // ---------------------------------------------------------------------- //
    // set up some styles

    /* styles -- the way lines, points, ... look like are -- managed centrally
     * by the Report in its stylesCollection. We later refer to these styles
     * by their index within the collection.
     */

    auto& stylesCollection = report.stylesCollection();

    /* since other showcase calls might have added other styles, we record the
     * number of registered styles before defining own styles and use this as
     * an offset.
     * In your code, you probably won't need to do that.
     */
    int linesStyleOffset = stylesCollection.getLineStyleCount();
    int pointStyleOffset = stylesCollection.getPointStyleCount();


    stylesCollection.addLineStyle("red");                                       // simply a red line; later referenced as <lineStyleOffset + 0>
    stylesCollection.addLineStyle("#ac1d1c");                                   // hex code specified colour name, as <lineStyleOffset + 1>
    stylesCollection.addLineStyle("blue", 2.5, "..-");                          // a blue line with 2.5pt thickness, dash-dotted, as <lineStyleOffset + 2>

    stylesCollection                                                            // <lineStyleOffset + 3>
    .addLineStyle("steelblue")                                                  // line styles may be changed after creation
    .setWidth(0.2)                                                              // this gives an alternative, more readable way of setting attributes
    ;

    stylesCollection.addPointStyle(PointForm::Diamond, "steelblue", 0.5);       // much the same holds for point styles, too. <pointStyleOffset + 0>

    stylesCollection
    .addPointStyle("*", "dark-chartreuse", 0.5)                                 // <pointStyleOffset + 1>
    .setOptions("pointinterval 5")                                              // not all options of gnuplot are natively supported. A options record/method usually allows to inject custom code
    ;

    // ---------------------------------------------------------------------- //
    // sheet 1: plots with default styles

    auto& sheet1 = report.addPlotDefault("default styles");

    /* A Dataview is an object representing one plot element (one line in a
     * line plot, or one series of data in a bar plot). It contains both,
     * format information (what kind of plot to generate, name of the data
     * series, what linestyle to use, ...) as well as references to the
     * actual data being plotted.
     *
     * There are different types of Dataviews for different formats of input
     * data and output formats. A DataviewSeparate takes one or several
     * std::vector<double>s as a data source for the plot to be generated.
     */

    sheet1.addDataviewDefaultSeparate(dataX, dataY, PlotStyle::Lines, "lines (by default)");

    sheet1
    .addDataviewDefaultSeparate()                                                  // apart from the constructor arguments, ...
    .setData(ColumnType::X, dataX)                                          // ... attributes can be set by chainable setter functions ...
    .setData(ColumnType::Y, dataY)                                          // ... which also throw exceptions in case of improper use.
    .setPlotStyleID(PlotStyle::Impulses)
    .setTitle("impulses")                                                   // When chaining, order matters since the returned type of the setters may only decrease in specificity
    ;

    /* Dataviews can also take strings that are then interpreted as functions.
     * Functions do not generate dat files and are mentioned in their analytic
     * form in the txt report
     */

    sheet1.addDataviewDefaultSeparate( "sin(x)", PlotStyle::Lines,        "sin(x)");
    sheet1.addDataviewDefaultSeparate( "cos(x)", PlotStyle::Lines,        "cos(x)");
    sheet1.addDataviewDefaultSeparate("-sin(x)", PlotStyle::LinesPoints, "-sin(x)");
    sheet1.addDataviewDefaultSeparate("-cos(x)", PlotStyle::LinesPoints, "-cos(x)");

    // ---------------------------------------------------------------------- //
    // sheet 2: plots with our styles

    /* below you'll find the same lines as above repeated, wit the insertion
     * of references to the generated styles.
     */

    auto& sheet2 = report.addPlotDefault("custom styles");

    sheet2
    .addDataviewDefaultSeparate(dataX, dataY, PlotStyle::Lines, "simData")
    .setLineStyle(linesStyleOffset)
    ;

    //! @todo duplicator functions here!
    sheet2
    .addDataviewDefaultSeparate()
    .setData(ColumnType::X, dataX)
    .setData(ColumnType::Y, dataY)
    .setLineStyle(linesStyleOffset + 1)                 // here
    .setPlotStyleID(PlotStyle::Impulses)
    .setTitle("simData")
    ;

    // and here, at the end of each line
    sheet2.addDataviewDefaultSeparate( "sin(x)", PlotStyle::Lines,       "sin(x)").setLineStyle  (linesStyleOffset + 2);
    sheet2.addDataviewDefaultSeparate( "cos(x)", PlotStyle::Lines,       "cos(x)").setLineStyle  (linesStyleOffset + 3);
    sheet2.addDataviewDefaultSeparate("-sin(x)", PlotStyle::LinesPoints, "-sin(x)").setPointStyle(pointStyleOffset    );
    sheet2.addDataviewDefaultSeparate("-cos(x)", PlotStyle::LinesPoints, "-cos(x)").setPointStyle(pointStyleOffset + 1);
}

// -------------------------------------------------------------------------- //

void showcase_run_compoundSimple(Plotypus::Report& report, std::vector<compound_t>& compound_data)
{
    /* In this example, the entire information what to plot (X-, Y-values,
     * error margins) are contained in a single vector. The code below
     * illustrates how to instruct Plotypus to work with such a compound object
     */

    using namespace Plotypus;

    // ---------------------------------------------------------------------- //
    // set up some styles

    auto& stylesCollection = report.stylesCollection();
    int linesStyleOffset = stylesCollection.getLineStyleCount();

    stylesCollection.addLineStyle("blue", 0.5, "", PointForm::Circle).setOptions("ps .5 pi 5");

    stylesCollection.addPointStyle(PointForm::Diamond, "gold", 0.5);

    // ---------------------------------------------------------------------- //
    // prepare selectors

    /* DataSelectors are functions that transform an object of type T into a
     * double. These functions are then applied to each element of the vector
     * to extract the data required for the plot
     *
     * The primary intent of them is to select a record of a struct or a
     * getter method of a class; however they may be as complex as your
     * code requires them to be.
     */

    using compound_selector_t = DataSelector_t<compound_t>;

    // *INDENT-OFF*
    compound_selector_t compoundSelectorX    = [] (const compound_t& data) {return data.x;};
    compound_selector_t compoundSelectorY    = [] (const compound_t& data) {return data.y;};
    compound_selector_t compoundSelectorErrX = [] (const compound_t& data) {return data.errX;};
    compound_selector_t compoundSelectorErrY = [] (const compound_t& data) {return data.errY;};

    compound_selector_t compoundSelectorXInv = [] (const compound_t& data) {return (pi * pi) / data.x;};
    // *INDENT-ON*


    // ---------------------------------------------------------------------- //
    // Sheet 1: cartesian line plots

    /* DataSelectors are used with a dedicated kind of DataView, the template
     * class DataviewDefaultCompound<T>. Since this is a bit of a mouth full, it can
     * be useful to define an alias name.
     */

    using compound_view_t = DataviewDefaultCompound<compound_t>;

    /* Otherwise, DataviewDefaultCompound<T> behaves just as
     * DataviewDefaultSeparate
     */

    auto& sheet1 = report.addPlotDefault("line plot (cartesian)");

    sheet1
    .addDataviewDefaultCompound<compound_t>(PlotStyle::YErrorLines, "Sine Approximation")
    .setData(compound_data)
    .setSelector(ColumnType::X,      compoundSelectorX)
    .setSelector(ColumnType::Y,      compoundSelectorY)
    .setSelector(ColumnType::DeltaY, compoundSelectorErrY)
    ;

    /* DataviewDefaultCompound<T> also allows analytic functions.
     * However, since <T> has to be spelled out each time the Dataview is
     * mentioned, it is preferred to use DataviewSeparate for that job.
     */

    sheet1.addDataviewDefaultCompound<compound_t>("[0:pi] sin(x)", PlotStyle::Steps, "Sine Wave");
    sheet1.addDataviewDefaultSeparate            ("[0:pi] cos(x)", PlotStyle::LinesPoints, "Cosine Wave");

    // ---------------------------------------------------------------------- //
    // retrieving references to the sheets dataviews

    /* If you didn't store a reference to the created dataview or cant't
     * apply all desired options on creation of the object, you may
     * retrieve it from the sheet object using dataviewAs.
     * The template argument is the Dataview (sub)class as which you want
     * to interpret the retrieved object.
     * The integer function argument is the zero-based index of the Dataview.
     * That means, the first Dataview created is index 0, the first one is
     * index 2 and so forth.
     */

    sheet1.dataviewAs<compound_view_t>(2).setLineStyle(linesStyleOffset);

    /* The same can be done to DataviewDefaultSeparate, too.
     */
    sheet1.dataviewAs<DataviewDefaultSeparate>(1).setLineStyle(linesStyleOffset);

    /* dataviewAs actually only applies a dynamic cast; the above line is
     * equivalent to (the more unwieldy line):
     */
    // dynamic_cast<DataViewDefaultCompound<compound_t>&>(sheet1.dataView(1)).setLineStyle(linesStyleOffset);

    /* the method dataview(index) works the same, but returns a reference to
     * the Dataview base object. This means that not all methods are available.
     */
    sheet1.dataview(0).setOptions("");      // as mentioned before, a options entity exists in most Plotypus objects, allowing injection of custom code.

    // Using dataviewAs with an incompatible class causes a catchable exception:
    // *INDENT-OFF*
    try                             {auto& ill_typed_reference = sheet1.dataviewAs<DataviewDefaultCompound<double>>(2);}
    catch (const std::bad_cast& e)  {/* std::cout << "prevented misinterpretation of dataview object" << std::endl; */}
    // *INDENT-ON*

    /* The same logic can be applied one level higher, to retrieve sheets from
     * the report, including the catchability of std::bad_cast.
     */
    auto& page1Basic = report.sheet(0);
    auto& page1Full  = report.sheetAs<PlotDefault>(0);
}

// -------------------------------------------------------------------------- //

void showcase_run_plots_multiplot(Plotypus::Report& report)
{
    /* This example illustrates the use of Multiplots, gnuplot's (and Plotypus')
     * way of putting several plots on a single page.
     */

    using namespace Plotypus;

    // ---------------------------------------------------------------------- //
    // generate a Multiplot object

    /* A Multiplot is a special kind of Sheet that can hold a number of sheets
     * as children. Multiplots cannot be nested, though.
     *
     * The most convenient way of using Multiplots involves setting up a grid.
     * The sheet is then divided in N times M fields which are then populated
     * in order.
     */
    auto& sheet1 = report
                   .addMultiplot("multiplot")
                   .setGridDimensions({1, 3})
                   .setStackingOrder(StackingOrder::Horizontal)         // These two methods controll in which order ...
                   .setStackingDirection(StackingDirection::Downwards)  // ... the subplots are arranged on the sheet.
                   ;

    // ---------------------------------------------------------------------- //
    // populate it with subplots

    /* The sheet then behaves just like a Report in the sense that adding
     * plots can be done as with the functions known from Report:
     */

    auto& subplot_1_1 = sheet1.addPlotDefault("subplot 1");
    auto& subplot_1_2 = sheet1.addSheet("subplot 2");
    auto& subplot_1_3 = sheet1.addPlotDefault("subplot 3");

    /* It is not possible to add a Multiplot to a Multiplot, and trying to do
     * so will raise an exception:
     */

    // *INDENT-OFF*
    try {auto& error = sheet1.addMultiplot("");}
    catch (const PlotypusError& e) {/* std::cout << "prevented a nested Multiplot, which is not supported by gnuplot." << std::endl; */}
    // *INDENT-ON*

    /* The subplots are no different from Plots directly under the Report.
     * They actually belong to the same class and and have identical
     * functionality
     */

    subplot_1_1
    .addDataviewDefaultSeparate("[0:2*pi]sin(x)")
    .setTitle("foo bar")
    ;
    subplot_1_3
    .addDataviewDefaultSeparate("[0:3*pi]cos(x)")
    .setTitle("BOO FAR")
    ;

    subplot_1_1.addLabel("foo bar", 0.1, 0.1);
    subplot_1_2.addLabel("FOO BAR", 0.1, 0.1);

    // ---------------------------------------------------------------------- //
    // automatic reset

    /* All settings made to a Multiplot page are terminated after creating the
     * last subplot. The subsequent page is completely independent from
     * what came before it.
     */

    auto& sheet2 = report.addSheet("Simple Sheet").addLabel("after a multiplot, the normal features are available as usual.", 0.05, 0.1);

    // ---------------------------------------------------------------------- //
    // blank fields

    /* When using a Multiplot grid, it is possible to leave some grid fields
     * empty. This is done with the setBlanks method. You need to pass a
     * list of one-based indices which fields should remain empty.
     */

    auto& sheet3 = report
                   .addMultiplot("blanks test")
                   .setGridDimensions({2, 2})
                   .setBlanks({2, 3})
                   ;

    auto& subplot_3_1 = sheet3.addPlotDefault("subplot 1");
    auto& subplot_3_2 = sheet3.addPlotDefault("subplot 2");

    subplot_3_1.addDataviewDefaultSeparate("[0:2*pi]sin(x)");
    subplot_3_2.addDataviewDefaultSeparate("[0:2*pi]cos(x)");

    // ---------------------------------------------------------------------- //
    // manual arrangement

    /* It is possible to control where each subplot ends up by using the
     * setSize and setOrigin methods on subplot level.
     */

    auto& sheet4 = report.addMultiplot("second one");
    auto& subplot_4_1 = sheet4.addPlotDefault("subplot 1");
    auto& subplot_4_2 = sheet4.addPlotDefault("subplot 2");

    subplot_4_1.setSize  (0.5, 1.0);
    subplot_4_2.setSize  (0.5, 1.0);
    subplot_4_2.setOrigin(0.5, 0.0);

    subplot_4_1.addDataviewDefaultSeparate("[0:pi]tan(x)");
    subplot_4_2.addDataviewDefaultSeparate("[0:pi]exp(x)");

    sheet4.addLabel("label on multiplot level behaves like subplot 1 element", 0.1, 40);
}


// -------------------------------------------------------------------------- //

void showcase_run_frameControls(Plotypus::Report& report)
{
    using namespace Plotypus;

    // ---------------------------------------------------------------------- //
    // obtaining the terminalInfoProvider

    /* the TerminalInfoProvider is a collection of metadata that controls the
     * overall format of the generated report. Options include size of the
     * document, file type, and anything you would set using the
     * set terminal
     * command.
     */

    auto& tip = report.terminalInfoProvider();

    // ---------------------------------------------------------------------- //
    // global settings

    tip
    .setFileType(FileType::Pdf)                                 // actually the default value, but just to hint at the alternatives
    .setDimensions(29.7, 21.0, LengthUnit::Centimeter)          // DIN A4 // todo: provide an enum-driven form for this
    ;

    // ---------------------------------------------------------------------- //
    // page level settings

    auto& sheet1 = report.addPlotDefault("halved page");

    sheet1
    .setSize  (0.7, 0.9)
    .setOrigin(0.0, 0.1)
    ;

    sheet1
    .axis(AxisType::X)
    .setRangeMin(0)
    .setRangeMax(5 * pi)
    .setLabelText("abscissa")
    ;

    sheet1
    .axis(AxisType::Y)
    .setRangeMin(0)
    .setRangeMax(1.2)
    .setLabelText("ordinate")
    ;

    Label lbl("Text outside of the plot range", 0.7, 0.5);
    lbl
    .setFont("Courier New, 20")
    .setPositionSystem(PositionSystem::Screen)
    ;

    sheet1.addLabel(lbl);

    sheet1.addDataviewDefaultSeparate("cos(x)", PlotStyle::Lines, "cosine");

    sheet1.key()
    .setPosition(Margin::Right, VerticalAlignment::Top)
    .setReverseSymbol(true)
    .setJustification(HorizontalAlignment::Left)
    ;

    /* Some key positions are mutually exclusive: for example, an object cannot
     * be both, at the bottom WITHIN the plot and at the bottom AT THE MARGIN
     * (i.e. WITHOUT the plot). Where a user attempts to set such a position,
     * an error is thrown.
     */

    // *INDENT-OFF*
    try {sheet1.key().setPosition(Margin::Bottom, VerticalAlignment::Bottom);}
    catch (const PlotypusError& e) {std::cout << "No double specification of key position" << std::endl;}
    // *INDENT-ON*

    // ---------------------------------------------------------------------- //
    // polar plots

    /* Adding a new plot automatically restores the size and origin */

    auto& sheet2 = report.addPlotDefault("polar plot");

    sheet2
    .setPolar(true)
    .setAspectEqual()
    .setBorder(BorderLine::Polar)
    ;

    sheet2
    .axis(AxisType::Radial)
    .setRangeMax(1.5)
    .setTicsLabels(
    {
        {"1/2", 0.5},
        {"one", 1.0},
        {"max", 1.25},
        {"1.5", 1.5}
    })
    ;
    sheet2
    .axis(AxisType::Azimuthal)
    .setRangeMax(180)
    ;

    /* the plot variable for polar plots is t (unless specified otherwise in a
     * custom script
     */
    sheet2.addDataviewDefaultSeparate("[0:pi]sin(5*t) + .25");

    // ---------------------------------------------------------------------- //
    // custom scripts

    // todo: showcase report level custom scripts

    sheet1
    .setCustomScriptBegin("# put here setup code that should be executed BEFORE the code generated by Plotypus")
    .setCustomScriptInter("# put here setup code that should be executed AFTER the code generated by Plotypus")
    .setCustomScriptEnd  ("# put here setup code that should be executed BEFORE the tidy up code generated by Plotypus but AFTER the plots");
}

// -------------------------------------------------------------------------- //

void showcase_run_plots2d_variety (Plotypus::Report& report,
                                   std::array<std::vector<double>, 5>& dataSep,
                                   std::vector<compound_t>& dataCmp)
{
    // ---------------------------------------------------------------------- //
    // usual setup

    using namespace Plotypus;

    using compound_selector_t = DataSelector_t<compound_t>;

    // *INDENT-OFF*
    compound_selector_t compoundSelectorX    = [] (const compound_t& data) {return data.x;};
    compound_selector_t compoundSelectorY    = [] (const compound_t& data) {return data.y;};
    compound_selector_t compoundSelectorErrX = [] (const compound_t& data) {return data.errX;};
    compound_selector_t compoundSelectorErrY = [] (const compound_t& data) {return data.errY;};

    compound_selector_t compoundSelectorXInv = [] (const compound_t& data) {return (pi * pi) / data.x;};
    // *INDENT-ON*

    // ---------------------------------------------------------------------- //
    // unpacking data

    /* Normally, you would simply pass a number of std::vector<double>& parameters.
     * Here, they are packed into a std::array for convenience.
     * The below line is structured binding, introduced in C++17. Should you be
     * unfamiliar with the concept: the below line is equivalent to:
     *
     * std::vector<double>& dataX = data[0],
     *                      dataY = data[1],
     *                      ...
     *                      ;
     */

    auto& [dataX, dataY, sizes, pointTypes, pointColor] = dataSep;

    // ---------------------------------------------------------------------- //
    // styles

    auto& stylesCollection = report.stylesCollection();

    /* since other showcase calls might have added other styles, we record the
     * number of registered styles before defining own styles and use this as
     * an offset.
     * In your code, you probably won't need to do that.
     */
    int linesStyleOffset = stylesCollection.getLineStyleCount();
    int pointStyleOffset = stylesCollection.getPointStyleCount();

    stylesCollection.addPointStyle(PointForm::Asterisk);
    stylesCollection.addLineStyle("blue", 0.5, "", PointForm::Point);
    stylesCollection.addLineStyle("light-blue");

    // ---------------------------------------------------------------------- //
    // axes setup

    auto setAxes = [] (PlotDefault& subplot, bool flipAxes = false)
    {
        const auto xAxis = flipAxes ? AxisType::Y : AxisType::X;
        const auto yAxis = flipAxes ? AxisType::X : AxisType::Y;

        subplot
        .axis(xAxis)
        .setRangeMin(0)
        .setRangeMax(pi)
        .setTicsIncrement(pi / 4.)
        .setTicsFormatstring("%4.2f")
        ;
        subplot
        .axis(yAxis)
        .setRangeMin(-1.5)
        .setRangeMax(+1.5)
        .setTicsIncrement(0.75)
        .setTicsFormatstring("%4.2f")
        ;
        subplot
        .axis(AxisType::X)
        .setTicsOptions("rotate by -90")
        ;

        subplot.setAspectSquare();
    };

    // ---------------------------------------------------------------------- //
    // Sheet 1: Points, Lines, LinesPoints

    auto& sheet1 = report
                   .addMultiplot("Lines and points")
                   .setGridDimensions(2, 3)
                   .setStackingDirection(StackingDirection::Downwards)
                   .setStackingOrder    (StackingOrder    ::Vertical)
                   ;

    auto& subplot_1_1 = sheet1.addPlotDefault("dots");
    subplot_1_1.addDataviewDefaultSeparate(dataX, dataY, PlotStyle::Dots, "");
    setAxes(subplot_1_1);

    auto& subplot_1_2 = sheet1.addPlotDefault("points ...");
    subplot_1_2.addDataviewDefaultSeparate(dataX, dataY, PlotStyle::Points, "");
    setAxes(subplot_1_2);

    auto& subplot_1_3 = sheet1.addPlotDefault("... with extra");
    subplot_1_3
    .addDataviewDefaultSeparate(dataX, dataY, PlotStyle::Points, "")
    .setData(ColumnType::Pointsize, sizes)
    .setData(ColumnType::Pointtype, pointTypes)
    .setData(ColumnType::Color, pointColor)
    ;
    setAxes(subplot_1_3);

    auto& subplot_1_4 = sheet1.addPlotDefault("lines");
    subplot_1_4.addDataviewDefaultSeparate(dataX, dataY, PlotStyle::Lines, "");
    setAxes(subplot_1_4);

    auto& subplot_1_5 = sheet1.addPlotDefault("linespoints");
    subplot_1_5.addDataviewDefaultSeparate(dataX, dataY, PlotStyle::LinesPoints, "");
    setAxes(subplot_1_5);

    auto& subplot_1_6 = sheet1.addPlotDefault("... with extra");
    subplot_1_6
    .addDataviewDefaultSeparate(dataX, dataY, PlotStyle::LinesPoints, "")
    .setData(ColumnType::Pointsize, sizes)
    .setData(ColumnType::Pointtype, pointTypes)
    .setData(ColumnType::Color, pointColor)
    ;
    setAxes(subplot_1_6);

    // ---------------------------------------------------------------------- //
    // Sheet 2: Points and Lines with errorbars

    auto& sheet2 = report
                   .addMultiplot("Error bars")
                   .setGridDimensions(2, 3)
                   ;

    auto& subplot_2_1 = sheet2.addPlotDefault("x error");
    subplot_2_1
    .addDataviewDefaultCompound<compound_t>(dataCmp, PlotStyle::XErrorBars, "")
    .setSelector(ColumnType::X, compoundSelectorX)
    .setSelector(ColumnType::Y, compoundSelectorY)
    .setSelector(ColumnType::DeltaX, compoundSelectorErrX)
    .setPointStyle(pointStyleOffset)
    ;
    setAxes(subplot_2_1);

    auto& subplot_2_2 = sheet2.addPlotDefault("y error");
    subplot_2_2
    .addDataviewDefaultCompound<compound_t>(dataCmp, PlotStyle::YErrorBars, "")
    .setSelector(ColumnType::X, compoundSelectorX)
    .setSelector(ColumnType::Y, compoundSelectorY)
    .setSelector(ColumnType::DeltaY, compoundSelectorErrY)
    .setPointStyle(pointStyleOffset)
    ;
    setAxes(subplot_2_2);

    auto& subplot_2_3 = sheet2.addPlotDefault("x/y error");
    subplot_2_3
    .addDataviewDefaultCompound<compound_t>(dataCmp, PlotStyle::XYErrorBars, "")
    .setSelector(ColumnType::X, compoundSelectorX)
    .setSelector(ColumnType::Y, compoundSelectorY)
    .setSelector(ColumnType::DeltaX, compoundSelectorErrX)
    .setSelector(ColumnType::DeltaY, compoundSelectorErrY)
    .setPointStyle(pointStyleOffset)
    ;
    setAxes(subplot_2_3);

    auto& subplot_2_4 = sheet2.addPlotDefault("and");
    subplot_2_4
    .addDataviewDefaultCompound<compound_t>(dataCmp, PlotStyle::XErrorLines, "")
    .setSelector(ColumnType::X, compoundSelectorX)
    .setSelector(ColumnType::Y, compoundSelectorY)
    .setSelector(ColumnType::DeltaX, compoundSelectorErrX)
    .setLineStyle(linesStyleOffset)
    ;
    setAxes(subplot_2_4);

    auto& subplot_2_5 = sheet2.addPlotDefault("with");
    subplot_2_5
    .addDataviewDefaultCompound<compound_t>(dataCmp, PlotStyle::YErrorLines, "")
    .setSelector(ColumnType::X, compoundSelectorX)
    .setSelector(ColumnType::Y, compoundSelectorY)
    .setSelector(ColumnType::DeltaY, compoundSelectorErrY)
    .setLineStyle(linesStyleOffset)
    ;
    setAxes(subplot_2_5);

    auto& subplot_2_6 = sheet2.addPlotDefault("line");
    subplot_2_6
    .addDataviewDefaultCompound<compound_t>(dataCmp, PlotStyle::XYErrorLines, "")
    .setSelector(ColumnType::X, compoundSelectorX)
    .setSelector(ColumnType::Y, compoundSelectorY)
    .setSelector(ColumnType::DeltaX, compoundSelectorErrX)
    .setSelector(ColumnType::DeltaY, compoundSelectorErrY)
    .setLineStyle(linesStyleOffset)
    ;
    setAxes(subplot_2_6);

    // ---------------------------------------------------------------------- //
    // Sheet 3: bar plots

    auto& sheet3 = report
                   .addMultiplot("bar plots")
                   .setGridDimensions(2, 3)
                   .setBlanks({4});

    auto& subplot_3_1 = sheet3.addPlotDefault("impulses");
    subplot_3_1.addDataviewDefaultSeparate(dataX, dataY, PlotStyle::Impulses, "");
    setAxes(subplot_3_1);

    auto& subplot_3_2 = sheet3.addPlotDefault("boxes");
    subplot_3_2.addDataviewDefaultSeparate(dataX, dataY, PlotStyle::Boxes, "");
    setAxes(subplot_3_2);

    auto& subplot_3_3 = sheet3.addPlotDefault("hor. boxes");
    subplot_3_3.addDataviewDefaultSeparate(dataX, dataY, PlotStyle::HBoxes, "");
    setAxes(subplot_3_3, true);

    auto& subplot_3_4 = sheet3.addPlotDefault("width-controlled");
    subplot_3_4.addDataviewDefaultSeparate(dataX, dataY, PlotStyle::Boxes, "").setData(ColumnType::Boxwidth, sizes);
    setAxes(subplot_3_4);

    auto& subplot_3_5 = sheet3.addPlotDefault("width-controlled");
    subplot_3_5.addDataviewDefaultSeparate(dataX, dataY, PlotStyle::HBoxes, "").setData(ColumnType::Boxwidth, sizes);
    setAxes(subplot_3_5, true);

    // ---------------------------------------------------------------------- //
    // Sheet 4: filled curves

    auto& sheet4 = report
                   .addMultiplot("filled curves")
                   .setGridDimensions(1, 2);

    auto& subplot_4_1 = sheet4.addPlotDefault("symmetrical errors");
    subplot_4_1
    .addDataviewDefaultCompound<compound_t>(dataCmp, PlotStyle::FilledCurves, "")
    .setSelector(ColumnType::X, compoundSelectorX)
    .setSelector(ColumnType::Y, compoundSelectorY)
    .setSelector(ColumnType::DeltaY, compoundSelectorErrY)
    .setLineStyle(linesStyleOffset + 1)
    ;
    subplot_4_1
    .addDataviewDefaultCompound<compound_t>(dataCmp, PlotStyle::Lines, "")
    .setSelector(ColumnType::X, compoundSelectorX)
    .setSelector(ColumnType::Y, compoundSelectorY)
    .setLineStyle(linesStyleOffset)
    ;
    setAxes(subplot_4_1);

    auto& subplot_4_2 = sheet4.addPlotDefault("explicit boundaries");
    subplot_4_2
    .addDataviewDefaultCompound<compound_t>(dataCmp, PlotStyle::FilledCurves, "")
    .setSelector(ColumnType::X, compoundSelectorX)
    .setSelector(ColumnType::YHigh, compoundSelectorY)
    .setSelector(ColumnType::YLow, compoundSelectorErrY)
    .setLineStyle(linesStyleOffset + 1)
    ;
    setAxes(subplot_4_2);

    // ---------------------------------------------------------------------- //
    // Sheet 5: steps

    auto& sheet5 = report
                   .addMultiplot("steps")
                   .setGridDimensions(1, 2);

    auto& subplot_5_1 = sheet5.addPlotDefault("steps");
    subplot_5_1.addDataviewDefaultSeparate(dataX, dataY, PlotStyle::Steps, "");
    setAxes(subplot_5_1);

    auto& subplot_5_2 = sheet5.addPlotDefault("fsteps and fillsteps");
    subplot_5_2.addDataviewDefaultSeparate(dataX, dataY, PlotStyle::FillSteps, "").setLineStyle(linesStyleOffset + 1);
    subplot_5_2.addDataviewDefaultSeparate(dataX, dataY, PlotStyle::FSteps, "")   .setLineStyle(linesStyleOffset);
    setAxes(subplot_5_2);
}

// -------------------------------------------------------------------------- //

void showcase_run_plots2d_maps(Plotypus::Report& report,
                               std::vector<compound_complex_t>& compound_complex,
                               std::array<std::vector<double>, 3>& separate_data)
{
    /* There is no principal between how Plotypus handles 2D and 3D information.
     * However, there are some additional options that are showcased here.
     */

    // ---------------------------------------------------------------------- //
    // usual setup


    using namespace Plotypus;

    auto& [sepData_X, sepData_Y, sepData_Z] = separate_data;

    using compound_selector_t = DataSelector_t<compound_complex_t>;
    using compound_view_t     = DataviewDefaultCompound<compound_complex_t>;

    // *INDENT-OFF*
    compound_selector_t compoundSelectorX      = [] (const compound_complex_t& data) {return data.coordinate.real();};
    compound_selector_t compoundSelectorY      = [] (const compound_complex_t& data) {return data.coordinate.imag();};
    compound_selector_t compoundSelectorDeltaX = [] (const compound_complex_t& data) {return data.value     .real();};
    compound_selector_t compoundSelectorDeltaY = [] (const compound_complex_t& data) {return data.value     .imag();};
    // *INDENT-ON*

    // ---------------------------------------------------------------------- //
    // Sheet 1: scalar field

    auto& sheet1 = report.addPlotDefault("scalar field");

    /* Gnuplot provides a dedicated style for scalar fields f(x, y), which
     * maps the function value to a colour. All of that can be handled in
     * the usual way.
     *
     * We will re-create this plot with different options, hence the
     * lambda expression
     */

    auto addPlotImage = [&separate_data] (PlotDefault& sheet)
    {
        auto& [sepData_X, sepData_Y, sepData_Z] = separate_data;

        sheet.addDataviewDefaultSeparate(PlotStyle::Image, "sin(2/r)")
        .setData(ColumnType::X, sepData_X)
        .setData(ColumnType::Y, sepData_Y)
        .setData(ColumnType::Color, sepData_Z)
        ;
    };

    addPlotImage(sheet1);

    // setting up the axes:

    auto setAxes = [] (PlotDefault& sheet)
    {
        sheet.axis(AxisType::X)                // setting up the axis happens as usual, but...
        .setRangeMin(-1.0)
        .setRangeMax(+1.0)
        .setTicsIncrement(.25)
        ;
        sheet.axis(AxisType::Y)
        .setRangeMin(-1.0)
        .setRangeMax(+1.0)
        .setTicsIncrement(.25)
        ;

        sheet.axis(AxisType::Colourbar)        // ... there is a new axis type involved in colour maps:
        .setLabelText("sin(2/r)")
        ;

        sheet.setAspectEqual();
    };

    setAxes(sheet1);

    // ---------------------------------------------------------------------- //
    // Sheet 2: Default palettes

    /* The mapping to a colour is done by means of a palette, of which
     * there are several predefined. * Most of them are taken from Python's
     * matplotlib; you will recognize them by their prefix Plt and the alike
     * name. Other than that, there also are some recommended palettes from the
     * makes of gnuplot.
     */

    auto& sheet2 = report
                   .addMultiplot("palettes (or some of them)")
                   .setGridDimensions(2, 3);

    auto& subPlot_2_1 = sheet2.addPlotDefault("plt: viridis");
    addPlotImage(subPlot_2_1);
    subPlot_2_1.paletteDescriptor().setMapping(NamedPalette::Plt_Viridis);

    auto& subPlot_2_2 = sheet2.addPlotDefault("plt: cividis");
    addPlotImage(subPlot_2_2);
    subPlot_2_2.paletteDescriptor().setMapping(NamedPalette::Plt_Cividis);

    auto& subPlot_2_3 = sheet2.addPlotDefault("plt: inferno");
    addPlotImage(subPlot_2_3);
    subPlot_2_3.paletteDescriptor().setMapping(NamedPalette::Plt_Inferno);

    auto& subPlot_2_4 = sheet2.addPlotDefault("gnu: rainbow");
    addPlotImage(subPlot_2_4);
    subPlot_2_4.paletteDescriptor().setMapping(NamedPalette::Gnu_Rainbow);

    auto& subPlot_2_5 = sheet2.addPlotDefault("gnu: Brilliant");
    addPlotImage(subPlot_2_5);
    subPlot_2_5.paletteDescriptor().setMapping(NamedPalette::Gnu_Brilliant);

    auto& subPlot_2_6 = sheet2.addPlotDefault("gnu: ocean");
    addPlotImage(subPlot_2_6);
    subPlot_2_6.paletteDescriptor().setMapping(NamedPalette::Gnu_Ocean);

    // ---------------------------------------------------------------------- //
    // Sheet 3: vector field

    /* For vector valued functions v(x, y) with v = (v_x, v_y), the PlotStyle
     * Vectors can be used. Analogously, for polar vectors v = (v_r, v_phi) the
     * PlotStyle Arrows can be used with the fields ColumnType::Angle and
     * ColumnType::Length
     */

    auto& sheet3 = report.addPlotDefault("vector field");

    sheet3.axis(AxisType::X)
    .setRangeMin (-1.5)
    .setRangeMax (+1.5)
    .clearTicsIncrement()
    .setLabelText(SYMBOL_REAL_PART);
    sheet3.axis(AxisType::Y)
    .setRangeMin (-1.5)
    .setRangeMax (+1.5)
    .clearTicsIncrement()
    .setLabelText(SYMBOL_IMAGINARY_PART);
    sheet3.setAspectSquare();

    sheet3.addDataviewDefaultCompound<compound_complex_t>(PlotStyle::Vectors, "vortex")
    .setData(compound_complex)
    .setSelector(ColumnType::X, compoundSelectorX)
    .setSelector(ColumnType::Y, compoundSelectorY)
    .setSelector(ColumnType::DeltaX, compoundSelectorDeltaX)
    .setSelector(ColumnType::DeltaY, compoundSelectorDeltaY);

    sheet3
    .key()
    .setPosition(Margin::Bottom, HorizontalAlignment::Right)
    ;
}

// -------------------------------------------------------------------------- //

void showcase_run_plots3d (Plotypus::Report& report, std::array<std::vector<double>, 3>& separate_data)
{
    using namespace Plotypus;

    // ---------------------------------------------------------------------- //
    // set up some styles

    auto& stylesCollection = report.stylesCollection();

    // ---------------------------------------------------------------------- //
    // separate data as before

    auto& [sepData_X, sepData_Y, sepData_Z] = separate_data;

    // ---------------------------------------------------------------------- //
    // Sheet 1: dots and image

    auto& sheet1 = report.addPlotDefault("3D dots");

    sheet1.axis(AxisType::X)
    .setRangeMin(-1.0)
    .setRangeMax(+1.0);
    sheet1.axis(AxisType::Y)
    .setRangeMin(-1.0)
    .setRangeMax(+1.0);
    sheet1.setAspectEqual();

    sheet1.addDataviewDefaultSeparate(PlotStyle::Dots3D, "sin(2/r)")
    .setData(ColumnType::X, sepData_X)
    .setData(ColumnType::Y, sepData_Y)
    .setData(ColumnType::Z, sepData_Z);

    // ---------------------------------------------------------------------- //
    // Sheet 2: image

    auto& sheet2 = report.addPlotDefault("3D Lines");

    sheet2.axis(AxisType::X)
    .setRangeMin(-1.0)
    .setRangeMax(+1.0);
    sheet2.axis(AxisType::Y)
    .setRangeMin(-1.0)
    .setRangeMax(+1.0);
    sheet2.setAspectEqual();

    sheet2.addDataviewDefaultSeparate(PlotStyle::Lines3D, "sin(2/r)")
    .setData(ColumnType::X, sepData_X)
    .setData(ColumnType::Y, sepData_Y)
    .setData(ColumnType::Z, sepData_Z);

    // ---------------------------------------------------------------------- //
    // Sheet 3: image

    auto& sheet3 = report.addPlotDefault("3D image");

    sheet3.addDataviewDefaultSeparate(PlotStyle::Image3D, "sin(2/r)")
    .setData(ColumnType::X, sepData_X)
    .setData(ColumnType::Y, sepData_Y)
    .setData(ColumnType::Z, sepData_Z)
    .setData(ColumnType::Color, sepData_Z)
    .setColumnFormat(ColumnType::Z, "(0)")
    .setBinaryDataOutput(false)
    ;

    sheet3.paletteDescriptor().setMapping(NamedPalette::Gnu_Hot);
}

